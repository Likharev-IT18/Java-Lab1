# Описание
Решение заданий из файла lab1_java.pdf  
# Использование
Скачать и запустить проект в IntelliJ IDEA
# Структура проекта
Проект разбит на 3 файла:  
Main.java - основной файл откуда вызываются методы менюшек,  
ChildMenus.java - менюшки выбора заданий,  
Task.java - решение заданий.
# Используемые методы заданий
Методы:
* **public int sumLastNums(int x);**  
  Складывает 2 последние цифры. Если меньше двух цифр, возвращает -1(ошибка).  
  Алгоритм:
  * Принимает целочисленное число типа int
  * Проверяет кол-во знаков. Если деление на 10 даёт 0, т.е меньше двух знаков, возвращает -1(ошибка)
  * Находит первое число, число десятков, по формуле (x%100)/10
  * Находит второе число, число едениц, по формуле x%10
  * Возвращает модуль суммы этих двух чисел.  
  Пример:  
1.Ввод: 1 -> Вывод: -1  
2.Ввод: 12 -> Вывод: 3
* **public boolean isPositive(int x);**  
  Возвращает true, если число больше 0, иначе false.  
  Алгоритм:
  * Принимает целочисленное число типа int
  * Возвращает булевое значение x>0, т.е если число больше 0 - вернется true, иначе false  
    Пример:  
1.Ввод: 1 -> Вывод: true  
2.Ввод: 23 -> Вывод: true  
3.Ввод: -5 -> Вывод: false
* **public boolean isUpperCase(char x);**  
  Возвращает true, если x - заглавная буква английского алфавита от A до Z  
    Алгоритм:
  * Принимает символ типа char
  * Создает локальную строку с алфавитом заглавных английских букв A-Z
  * Перебирает строку с помощью цикла for
  * Если буква в строке совпадает с данным x, возвращает true
  * Если цикл прошел и не нашел совпадения, возвращает false  
    Пример:  
1.Ввод: H -> Вывод: true  
2.Ввод: L -> Вывод: true  
3.Ввод: n -> Вывод: false  
4.Ввод: ф -> Вывод: false
* **public boolean isDivisor(int a, int b);**  
  Возвращает true, если число a делится на b без остатка или число b делится на a без остатка    
  Алгоритм:
  * Принимает два аргумента int a, int b  
  * Возвращает булевое значение "(a%b==0) или (b%a==0)", т.е. если одно из чисел делится на другое без остатка - вернется true, в другом случае false  
    Пример:  
1.Ввод: 8, 2 -> Вывод: true  
2.Ввод: 3, 6 -> Вывод: true  
3.Ввод: 2, 15 -> Вывод: false  
4.Ввод: 7, 5 -> Вывод: false  
5.Ввод: -4, 2 -> Вывод: true
* **public int lastNumSum(int a, int b);**  
  Возвращает сумму двух чисел из разряда едениц.  
  Алгоритм:
  * Принимает два аргумента int a, int b  
  * Возвращает a%10 + b%10, сумму разряда едениц двух чисел   
    Пример:  
1.Ввод: H -> Вывод: true  
2.Ввод: L -> Вывод: true  
3.Ввод: n -> Вывод: false  
4.Ввод: ф -> Вывод: false

Условия:  
* **public double safeDiv(int x, int y);**  
  Возвращает деление x на y. Если y=0, возвращает 0 чтобы избежать ошибок  
  Алгоритм:
  * Принимает два аргумента int x, int y  
  * Если y=0, возвращает 0.
  * Иначе возвращает x/y типа double.   
    Пример:  
1.Ввод: 5, 0 -> Вывод: 0  
2.Ввод: 8, 2 -> Вывод: 4  
* **public String makeDecision(int x, int y);**  
  Возвращает строку с подходящим знаком для равенства x и y.  
  Алгоритм:  
  * Принимает два аргумента int x, int y
  * Создает вспомогательную строку str для возвращения результата    
  * Записывает строку с нужным знаком. Если x>y, записывает в строку "x>y". Иначе если x<y, записывает в строку "x<y". Иначе получаем равенство, записываем в строку "x==y"
  * Возвращаем строку str.  
    Пример:  
1.Ввод: 5, 7 -> Вывод: 5<7  
2.Ввод: 8, -1 -> Вывод: 8>-1  
3.Ввод: 4, 4 -> Вывод: 4==4  
* **public boolean sum3(int x, int y, int z);**  
  Возвращает true, если при сложении любых 2-х чисел сумма будет равна 3-ему.  
  Алгоритм:  
  * Принимает три аргумента int x, int y, int z  
  * Возвращает true, если можно сложить два любых числа и получить третье. То есть возвращает true, если x+y=z или x+z=y или y+z=x. В другом случае false.  
    Пример:  
1.Ввод: 5, 7, 2 -> Вывод: true  
2.Ввод: 8, -1, 4 -> Вывод: false  
* **public String age(int x);**  
  Возвращает строку, в которой к числу x будет добавлено подходящее слово "год, года, лет".  
  Алгоритм:  
  * Принимает число int x  
  * Если x делится на 10 с остатком 1 и x не 11, возвращает строку "x год".  
  * Иначе если x делится на 10 с остатками 2 или 3 или 4 и x не число 12,13,14, возвращает строку "x года"  
  * В других случаях возвращает строку "x лет"  
    Пример:  
1.Ввод: 5 -> Вывод: 5 лет  
2.Ввод: 22 -> Вывод: 22 года  
* **public void printDays(String x);**  
  Выводит с определенного дня недели, оставшиеся до конца недели дни(т.е. до воскресенья)  
  Алгоритм:  
  * Принимает строку x  
  * Проверяет с помощью оператора switch чему равен x, в case записаны дни недели по порядку без оператора break, выводит с определенного дня до конца недели все дни.    
  * Если x не день недели, выводит "Это не день недели..."  
    Пример:  
1.Ввод: понедельник -> Вывод:  
понедельник  
вторник  
среда  
четверг  
пятница  
суббота  
воскресенье  
2.Ввод: пятница -> Вывод:  
пятница  
суббота  
воскресенье    

Циклы:  
* **public String reverseListNums(int x);**  
  Возвращает строку где записаны все числа от x до 0(включительно).  
  Алгоритм:  
  * Принимает число int x  
  * Создает вспомогательную строку str  
  * Перебирает циклом for от i=x до i=0 при этом уменьшая i на 1.  
  * Если i не равно 0, то добавляет в строку i и пробел для отеления числел друг от друга(i + " "). В другом случае если i=0, добавляет в строку просто 0 без пробелов.  
  * Возвращает строку str  
    Пример:  
1.Ввод: 5 -> Вывод: "5 4 3 2 1 0"  
2.Ввод: 2 -> Вывод: "2 1 0"  
* **public int pow(int x, int y);**  
  Возвращает возведение x в степень y.  
  Алгоритм:  
  * Принимает два аргумента int x, int y  
  * Создает вспомогательную переменную p=1  
  * Перебирает циклом for от 0 до y при этом увеличивая i на 1.  
  * В цикле записывает в p умножение p*x, таким образом получая x в степени y  
  * Возвращает p  
    Пример:  
1.Ввод: 2, 5 -> Вывод: "32"  
2.Ввод: 3, 3 -> Вывод: "27"  
* **public boolean equalNum(int x);**  
  Возвращает true, если все знаки в числе x одинаковые.  
  Алгоритм:  
  * Принимает аргумент int x  
  * Создает вспомогательные переменные int num=10 для проверки следующего знака и int znak=x%10 в котором знак числа который сравниваем.  
  * Перебирает циклом while пока целая часть от деления x/num не равна 0(пока есть ещё знаки).  
  * Вычисляем текущий непроверенный знак (x%(num\*10))/num, если не равен предыдущему знаку znak, возвращаем false. В num записываем следующий знак (num\*10). 
  * Если цикл прошел успешно и не вернул false, значит все знаки одинаковые, возвращает true.  
    Пример:  
1.Ввод: 1111 -> Вывод: "true"  
2.Ввод: 1211 -> Вывод: "false"  
* **public void leftTriangle(int x);**  
  Выводит триугольник звездочками, где x-колво строк и в каждой строке столько звездочек("*"), какой номер строки.  
  Алгоритм:  
  * Принимает аргумент int x  
  * Создает локальную переменную со звёздочкой String str = "*"  
  * Перебирает циклом for от i=0, при этом увеличивая i на 1  
  * Выводит строку str со звездочками.  
  * Добавляет одну звёздочку в конец строки str+="*"  
  * Делает цикл до тех пор пока i<x.  
    Пример:  
1.Ввод: 2 -> Вывод:  
\*  
**  
1.Ввод: 3 -> Вывод:  
\*  
**  
\***  
* **public void guessGame();**  
  Угадайка. Дано рандом число от 0 до 9, нужно его угадать.  
  Алгоритм:  
  * Создает локальные переменные boolean success=false для проверки угадано ли число и записывает рандомное число от 0 до 9 в int randomNumber. int attempts=0 для того чтобы считать количество попыток.  
  * Просит пользователя ввести число "Введите число от 0 до 9:"  
  * Создает цикл while пока success=false.  
  * Читает введённые пользователем данные в переменную int enterNumber.  
  * Если число меньше 0 или больше 9 то выводит "Число может быть от 0 до 9" "Введите число от 0 до 9:" и продолжает цикл заново с помощью continue  
  * Если число от 0 до 9 продолжает выполнение.  
  * Добавляет попытку attempts++.  
  * Если введенное число enterNumber равно рандомному randomNumber то выводит "Вы угадали число за [attempts] попыток" и присваивает success = true.  
  * Иначе выводит "Вы не угадали число, введите число от 0 до 9:"  
  * Переходит в начало цикла.  
    Пример:  
    <img width="501" height="210" alt="1" src="https://github.com/user-attachments/assets/9efd684f-c0ae-4fe0-a140-20c1525ddfc8" />


Массивы:  
* **public int findLast(int[] arr, int x);**  
  Проходит по массиву и возвращает индекс последнего найденного элемента x, если не найден - возвращает -1.  
  Алгоритм:  
  * Принимает аргументы массив int[] arr и искомый элемент int x  
  * Создает локальную переменную - индекс последнего найденного числа int index=-1  
  * Перебирает циклом for весь массив от i=0 до конца массива при этом увеличивая i на 1.  
  * Если число под индексом i будет равно x, то записывает в index индекс найденного элемента i. 
  * Идет с начала цикла, таким образом находя индекс последнего элемента.  
  * Возвращает index. Если элементов равных x нет в массиве, вернется -1.  
    Пример:  
1.<img width="206" height="80" alt="2" src="https://github.com/user-attachments/assets/a0deaa2d-5784-45c5-b436-f1d5ebb2801f" />  
2.<img width="199" height="81" alt="3" src="https://github.com/user-attachments/assets/5d26e447-beb5-41a2-a0aa-4d89ee79d6c2" />  

* **public int[] add(int[] arr, int x, int pos);**  
  Добавляет элемент x в позицию pos и возвращает новый массив.  
  Алгоритм:  
  * Принимает аргументы массив int[] arr, добавляемые элемент int x, позицию куда добавить элемент int pos  
  * Создает новый массив int[] newArray с размером данного массива arr+1  
  * Перебирает циклом for весь массив от i=0 для нового массива и i1=0 для данного массива до конца данного массива arr при этом увеличивая i и i1 на 1.  
  * Если число под индексом i не будет равно позиции pos, то записывает в новый массив newArray[i] элемент из данного массива arr[i1].  
  * Иначе если индекс i будет равен позиции pos, добавляет в новый массив новый элемент x и уменьшает индекс i1 данного массива arr на 1(i1--) чтобы добавлять элементы дальше.  
  * Идет по циклу пока i меньше размера нового массива.  
  * Возвращает новый массива newArray.  
    Пример:  
1.<img width="264" height="107" alt="4" src="https://github.com/user-attachments/assets/04e1683f-7c9c-45c4-b9da-a29b51758fed" />  
2.<img width="272" height="108" alt="5" src="https://github.com/user-attachments/assets/d31a7ad5-a5f6-448d-9ff8-619e3f7b15e7" />  

* **public void reverse(int[] arr);**  
  Проходит с правого и левого края, изменяя элементы. Переворачивает массив.  
  Алгоритм:  
  * Принимает массив int[] arr  
  * Запоминает индексы левого и правого элементов массива: int left=0, int right=arr.length-1  
  * Перебирает циклом while весь массив пока указатели не встретятся или не пересекутся (left < right).  
  * Сохраняет значение левого элемента в int temp, в arr[left] записывает правый элемент arr[right] и в правый записывает значение arr[right]=temp  
  * Добавляет к левому индексу 1, из правого вычитает 1  
  * Идет по циклу сначала.  
  Пример:  
1.<img width="271" height="58" alt="6" src="https://github.com/user-attachments/assets/ff9ecb78-3452-4c9d-8633-ebe57179e45b" />  
2.<img width="283" height="58" alt="7" src="https://github.com/user-attachments/assets/c4d796d2-bb9b-4195-b765-654797f77a2a" />  

* **public int[] concat(int[] arr1, int[] arr2);**  
  Возвращает новый массив, объединение двух массивов arr1 и arr2.  
  Алгоритм:  
  * Принимает два массива int[] arr1 и int[] arr2  
  * Создает новый массив int[] newArray с размером двух массивов arr1+arr2  
  * Перебирает циклом while весь массив пока указатели не встретятся или не пересекутся (left < right).  
  * Создает локальную переменную int index=0 для отслеживания куда добавлять элемент в новый массив.  
  * Перебирает циклом for первый массив от i=0 до i<arr1.length с шагом 1. Записывает элементы из arr1[i] в новый массив newArray[index] и увеличивает index на 1.  
  * Перебирает циклом for второй массив от i=0 до i<arr2.length с шагом 1. Записывает элементы из arr2[i] в новый массив newArray[index] и увеличивает index на 1.  
  * Возвращает новый массив newArray.  
  Пример:  
1.<img width="304" height="92" alt="8" src="https://github.com/user-attachments/assets/5d34fd46-6142-4833-9ac0-f58942de41f2" />  
2.<img width="371" height="78" alt="9" src="https://github.com/user-attachments/assets/0022b75b-13ef-4c4c-a7a6-9fb532662d46" />  


* **public int[] deleteNegative(int[] arr);**  
  Возвращает новый массив, в котором нет отрицательных значений.  
  Алгоритм:  
  * Принимает массив int[] arr  
  * Создает локальную переменную int counterNegative=0 для подсчёта отрицательных значений в массиве  
  * Перебирает циклом for массив от i=0 до i<arr.length с шагом 1. Если элемент arr[i] меньше нуля, добавляет 1 в счётчик counterNegative.  
  * Создает новый массив int[] newArray с размером массива минус кол-во негативных элементов(arr.length-counterNegative)  
  * Перебирает циклом for массив от i=0 до i<arr.length с шагом 1 и вспомогательной переменной i1=0 индексом нового массива.  
  * Если элемент arr[i] больше нуля, добавляет элемент из массива arr[i] в новый массив newArray[i]. Увеличивает индекс вспомогательной переменной для индекса нового массива i1 на 1.  
  * Возвращает новый массив newArray.  
  Пример:  
1.<img width="218" height="56" alt="10" src="https://github.com/user-attachments/assets/12cf39ae-9f67-415f-8423-c80bc4fec926" />  
2.<img width="368" height="55" alt="11" src="https://github.com/user-attachments/assets/dd1e0b36-8202-4353-8615-2a0964bfad20" />  

